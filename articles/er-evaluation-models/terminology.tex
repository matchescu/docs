Throughout this paper the term ``entity'' is reserved for real-world items.
This requires introducing new terms for the computer-friendly representations of
entities.
We start by saying that when entity resolution is performed by computers, it
uses data sources.

\begin{defn}
    A \textit{data source} represents a sequence of decoded messages
    that originate somewhere and can be processed by a computer program that
    reads them over a communication channel\footnote{The terms `decoded', `message' and `communication channel' refer to concepts
    defined in information theory~\cite{ash2012it}.}.
\end{defn}



An entity resolution task needs at least one data source to operate on.
When the relevant information is split across multiple data sources, these
can be merged back into a single source.
Similarly, a single data source can be split into multiple data sources.
Data sources may be bounded (files or databases) or unbounded (streams).
For the purposes of this paper, these attributes of data sources as well as
their number are inconsequential.
In practical terms and as far as we are concerned it should suffice to know that
entity resolution is a computer process that operates over data sources.

Entity resolution requires at least a minimal conceptual structuring of data in
attributes, references and traits.

\begin{defn}
    An \textit{attribute} is information about an entity that has a certain
    meaning in a context given by a frame of reference and certain rules of
    interpretation.
\end{defn}

Attributes by themselves are not enough to describe any entity.
For example, while `red' fully describes a color it does not fully describe a 
fruit.

\begin{defn}
    An \textit{entity reference} is a collection of attributes that refer
    to a real-world entity which is constructed by following an organizing
    principle applied to the data source containing the attributes.
\end{defn}

We refer to the way data is organized in a data source as the organizing
principle of that data source.
Although tempting, it should not be confused with the way data is structured in
a data source.
For example, most would agree that a CSV file is a semi-structured data source.
The organizing principle that is interesting for entity resolution does not need
to follow the structure of the CSV file.
Indeed, if we are simply interested in named entity recognition and
disambiguation we might only care about `mentions' and treat the file as if it
were unstructured text.
The process of entity resolution loads \textit{references} from a data source by
taking advantage of the way that data source is organized~\cite{Ben2009Swoosh}.

Entity reference extraction also varies a lot on the application context.
For entity resolution tasks where geographic data is of particular importance,
geolocation data will be extracted into entity references to the detriment of
other types of information.
Similarly, in tasks that aim to build people profiles, entity references will
almost always favour extracting dates of birth and names over anything else.

In short, the organizing principle of a data source in the context of entity
resolution is extrinsic to the data source and it is driven by the purpose of
performing entity resolution.

\begin{defn}
    A \textit{trait} is an algorithm that serves the purpose for which entity
    resolution is performed and which is used for entity reference extraction
    from a data source. The organizing principle of a data source is comprised
    from all the traits needed to extract entity references from that data
    source.
\end{defn}

Entity resolution is performed with purpose and agency.
There are specific objectives involved, such as medical diagnoses, plagiarism
detection or illegal financial transaction monitoring.
Different purposes bring into existence different key rules that guide the
interpretation of the available data, emphasizing certain aspects over others.
These rules are typically implemented deliberately to serve the purpose for
performing entity resolution.

While we might think of traits as being a part of a generic data extraction
process such as scraping, traits in the sense described here are actually
integral to the entity resolution process itself.
In practice, generic data collection and extraction usually come into play when
constructing the input data sources used in the entity resolution process.
On the other hand, traits come into play within entity resolution when
constructing entity references.

The most similar notion to that of a trait is the pattern recognition notion of
a `feature':
\textit{an individual measurable property or characteristic of a
phenomenon}\cite{bishop2006pattern}.
The difference between a trait as defined here and a pattern recognition feature
is a matter of perspective.
Features are part of constructing a broader, objective perspective on
information.
Traits as they are defined here are concerned with mapping objective information
to the entity resolution context.

Pragmatically, traits can be viewed as computing functions that process data
according to the subjective goal of the entity resolution task.
Traits might be configuration parameters for an entity resolution system or they
algorithms that are part of the a system's code.
For example, a trait called `profitable' that applies to companies would entail
writing an algorithm that outputs a truth value when gains exceed spending.
Another example of a trait, is a configuration value that specifies the
attributes that should be used when comparing two entity references.
Some entity resolution algorithms allow configuring thresholds (such as the
Jaccard threshold~\cite{jaccard1912}) to determine an upper limit to the number
of attributes of entity references.

In contrast to attributes, traits are not a part of the entity resolution input.
Each specific implementation of entity resolution includes its own traits.
Entity resolution computer programs extract attributes to construct entity
references based on the programs' specific traits.
They are a necessary abstraction that allows us to envision multiple entity
resolution implementations over the same data source.

Entity references are the basic building block for performing entity resolution.
While it is entirely possible to represent a real-world item with just one
entity reference, that representation will likely be far from useful.
Instead, real-world items are represented on the computer using \textit{entity
profiles}.

\begin{defn}
    The logical grouping of entity references that point to the same real-world
    object throughout entity resolution is known as the \textit{entity profile}
    of the real-world object.
\end{defn}

By using the terms \textit{data source}, \textit{attribute},
\textit{trait}, \textit{entity reference} and \textit{entity profile} we can
finally move on to define entity resolution formally.
